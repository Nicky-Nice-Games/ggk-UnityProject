using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

//-----------------------------------------------
//
//          MINIMAP TOOL: HOW TO USE
//
//-----------------------------------------------

//-----------------USING POINTS------------------
//
// 1. The "points" field is a list of points that the script will use to generate a set of bounds.
//    Add points by adding Vector3s to the list as needed.
// 2. The script will use the points to generate a center, width, height, and depth that encloses
//    the shape created by the connected points.
// 2. If you don't want to use points and instead wish to set these variables yourself, ensure the 
//    "usePoints" boolean is unchecked.
//
//---------------USING DIMENSIONS----------------
//
// 1. The "center", "width", "height", and "depth" fields are the locations and dimensions of the box
//    that the map will track. set these accordingly: width is the X, height the Z, and depth Y.
// 2. Done! The script will track objects' locations relative to the box.
//
//----------------ADDING OBJECTS-----------------
//
// 1. Add objects to track by adding their GameObjects to the "objects" GameObject list. Ensure these objects
//    have an "AppearanceSettings" component if you wish to specify their appearance on the map. 
// 2. Do NOT add anything to the "mapIcons" list. This will populate itself automatically. 
//
//----------------TRACKING DEPTH-----------------
//
// 1. If you don't want to track depth, check the "ignoreDepth" boolean.
// 2. Change the "averageSize:" float to change the size of the icons a tthe middle. an averageSize of 1 means that the 
//    icons are normally at 5% of the minimap's size.
// 3. Change the min/maxDepthTracking to change the y values that the icons will change size to reflect. If the object's
//    position exceeds these bounds, the object will not get any smaller/larger.
// 4. Change the "sizeOffset" variable to change the maximum change in size that the icon will reflect.
//
//---------------------DEBUG----------------------
//
// [IMPORTANT]
// 1. Uncheck the "showDebug" variable if you do not wish to show the bounds generated by the program.
//    Failiure to account for this can lead to unexpected errors!
//
public class MiniMapHud : MonoBehaviour
{
    public static MiniMapHud instance;
    //use these if you want to use points
    [Header("Map Bounds (Points)")]
    // list of points
    [SerializeField] private List<Vector3> points;

    //Should you use the four points(above) as opposed to a center then box size(below)?
    [SerializeField] private bool usePoints;

    //Use these if you want to use a box
    [Header("Map Bounds(Box)")]
    // width, height, depth of the game space that the UI should cover
    [SerializeField] private Vector3 center;
    //x, z, y indexes
    [SerializeField] private int width, height, depth;

    [Header("Objects")]
    // a list of objects to track on the map
    [SerializeField] private List<GameObject> objects;
    //..along with their respective icons on the map
    [SerializeField] private List<Image> mapIcons;

    [Header("Depth")]
    // should icons on the map
    // change size to indicate depth?
    [SerializeField] private bool ignoreDepth;
    //Size multiplier of the average icon. 1x size is at 5% of the Minimap's size.
    [SerializeField] private float averageSize;
    //maximum, minimum y values the hud will change size to reflect
    [SerializeField] private float maxDepthTracking;
    [SerializeField] private float minDepthTracking;
    //how much larger/smaller should icons get at its maximum? 
    [SerializeField] private float sizeOffset;


    [Header("Misc.")]
    //should debug things (line renderers, for example) show?
    [SerializeField] private bool showDebug;
    [SerializeField] private float iconSpinoutSpeed;
    //canvas
    private Canvas canvas;
    //the minimap that bounds should follow
    private Image miniMap;
    //reference icon
    private GameObject iconRef;
    //Line renderers for calculated bounds and/or points
    private LineRenderer boundsMaker;
    private LineRenderer pointsMaker;

    public List<IEnumerator> spinInstances = new List<IEnumerator>();

    // Awake is called before start wether or not the object is active
    private void Awake()
    {
        instance = this;
    }

    // Start is called before the first frame update
    void Start()
    {
        canvas = GetComponent<Canvas>();

        if (showDebug)
        {
            boundsMaker = GameObject.Find("MapBounds").GetComponent<LineRenderer>();
            pointsMaker = GameObject.Find("Points").GetComponent<LineRenderer>();
        }

        if (usePoints)
        {
            //establish the bounds using the 4 points
            EstablishBounds(points);
        }
        DebugBounds();

        //find the minimap and icon reference
        miniMap = GameObject.Find(gameObject.name + "/MiniMap").GetComponent<Image>();
        iconRef = GameObject.Find(gameObject.name + "/MiniMap/MapIcon");

        //If there are objects to track..
        if (objects.Count > 0)
        {
            //add objects to the icon list
            iconRef.SetActive(true);
            Image refImage = iconRef.GetComponent<Image>();
            mapIcons.Add(refImage);

            EstablishAppearance(objects[0], refImage);

            //create more icons as more are needed
            for (int i = 1; i < objects.Count; i++)
            {
                GameObject newIcon = Instantiate(iconRef, miniMap.gameObject.transform);
                refImage = newIcon.GetComponent<Image>();
                mapIcons.Add(refImage);

                EstablishAppearance(objects[i], refImage);
            }

            foreach (GameObject obj in objects)
            {
                ItemHolder holder = obj.GetComponent<ItemHolder>();
                if (obj.transform.parent != null)
                {
                    DynamicRecovery[] recovery = obj.transform.parent.GetComponentsInChildren<DynamicRecovery>();
                    if (recovery.Length > 0)
                    {
                        foreach (DynamicRecovery r in recovery)
                            r.miniMap = this;
                    }
                }

                if (holder)
                {
                    holder.miniMap = this;
                }

            }
        }
    }

    // Update is called once per frame
    void Update()
    {
        //update icon position
        for (int i = 0; i < objects.Count; i++)
        {
            //calulate position
            Vector3 objPos = objects[i].transform.TransformPoint(0, 0, 0);
            Vector2 miniMapSize = miniMap.rectTransform.sizeDelta;

            float xBoundMin = center.x - (width / 2);
            float xBoundMax = center.x + (width / 2);
            float yBoundMin = center.z - (height / 2);
            float yBoundMax = center.z + (height / 2);

            float xLerp = Mathf.InverseLerp(xBoundMin, xBoundMax, objPos.x);
            float yLerp = Mathf.InverseLerp(yBoundMin, yBoundMax, objPos.z);

            float xPos = Mathf.Lerp(-miniMapSize.x / 2, miniMapSize.x / 2, xLerp);
            float yPos = Mathf.Lerp(-miniMapSize.y / 2, miniMapSize.y / 2, yLerp);

            //set new icon position
            mapIcons[i].transform.localPosition = new Vector3(xPos, yPos, 0);

            if (!ignoreDepth)
            {
                //calculate icon size
                //default size-- 5% of minimap size times average size multiplier
                float defSize = (Mathf.Sqrt(miniMapSize.x * miniMapSize.y) / 20) * averageSize;

                //map icon size
                Vector2 size = mapIcons[i].rectTransform.sizeDelta;

                //position of the depth as a value between 0 and 1
                float lerp = Mathf.InverseLerp(minDepthTracking, maxDepthTracking, objPos.y);

                //use lerp value to lerp between min size and max size
                float iconSize = Mathf.Lerp((defSize / sizeOffset), (defSize * sizeOffset), Mathf.Clamp(lerp, 0, 1));

                //set new icon size
                mapIcons[i].rectTransform.sizeDelta = new Vector2(iconSize, iconSize);
            }
        }
    }

    //---------------------------------
    //-------------FUNCTIONS-----------
    //---------------------------------

    /// <summary>
    /// (DEPRECATED)Establishes the play area's bounds using four points.  
    /// The play area's bounds will be set to the smallest rectangle that encompasses
    /// the polygon formed by the points.
    /// </summary>
    /// <param name="tLeft">The point at the top left of the polygon.</param>
    /// <param name="tRight">The point at the top right of the polygon.</param>
    /// <param name="bLeft">The point at the bottom left of the polygon.</param>
    /// <param name="bRight">The point at the bottom right of the polygon.</param>
    private void EstablishBounds(Vector3 tLeft, Vector3 tRight, Vector3 bLeft, Vector3 bRight)
    {
        if (showDebug)
        {
            pointsMaker.positionCount = 5;
            pointsMaker.SetPosition(0, tLeft);
            pointsMaker.SetPosition(1, tRight);
            pointsMaker.SetPosition(2, bRight);
            pointsMaker.SetPosition(3, bLeft);
            pointsMaker.SetPosition(4, tLeft);
        }

        List<Vector3> pointList = new List<Vector3> { tLeft, tRight, bLeft, bRight };

        EstablishBounds(pointList);
    }

    /// <summary>
    /// Establishes the play area's bounds using a list of points.  
    /// The play area's bounds will be set to the smallest rectangle that encompasses
    /// the polygon formed by the points.
    /// </summary>
    /// <param name="pointList">A list of points to use.</param>
    private void EstablishBounds(List<Vector3> pointList)
    {
        float minX, minY, minZ;
        minX = minY = minZ = Mathf.Infinity;
        float maxX, maxY, maxZ;
        maxX = maxY = maxZ = -Mathf.Infinity;

        foreach (Vector3 point in pointList)
        {
            //if this point's x value is the largest so far..
            if (point.x > maxX)
            {
                maxX = point.x;
            }
            // or the smallest so far...
            else if (point.x < minX)
            {
                minX = point.x;
            }

            //if this point's y value is the largest so far...
            if (point.y > maxY)
            {
                maxY = point.y;
            }
            //or the smallest so far...
            else if (point.y < minY)
            {
                minY = point.y;
            }

            //if this point's z value is the largest to far...
            if (point.z > maxZ)
            {
                maxZ = point.z;
            }
            //or the smallest so far...
            else if (point.z < minZ)
            {
                minZ = point.z;
            }
        }

        //set the center to the midpoint of the points
        Vector3 c = new Vector3((minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2);

        //calculate width. height, and depth
        int w = (int)(maxX - minX);
        int h = (int)(maxZ - minZ);
        int d = (int)(maxY - minY);

        EstablishBounds(c, w, h, d);
    }

    /// <summary>
    /// Establishes the play area's bounds using box dimensions and a center.
    /// </summary>
    /// <param name="center"></param>
    /// <param name="width"></param>
    /// <param name="height"></param>
    /// <param name="depth"></param>
    private void EstablishBounds(Vector3 center, int width, int height, int depth)
    {
        this.center = center;
        this.width = width;
        this.height = height;
        this.depth = depth;

        DebugBounds();
    }

    private void DebugBounds()
    {
        if (showDebug)
        {
            boundsMaker.positionCount = 5;
            boundsMaker.gameObject.transform.position = center;
            boundsMaker.SetPosition(0, new Vector3(-width / 2, 2, height / 2));
            boundsMaker.SetPosition(1, new Vector3(width / 2, 2, height / 2));
            boundsMaker.SetPosition(2, new Vector3(width / 2, 2, -height / 2));
            boundsMaker.SetPosition(3, new Vector3(-width / 2, 2, -height / 2));
            boundsMaker.SetPosition(4, new Vector3(-width / 2, 2, height / 2));
        }

    }

    private void EstablishAppearance(GameObject obj, Image img)
    {
        AppearanceSettings settings = obj.GetComponent<AppearanceSettings>();

        if (settings != null)
        {
            img.sprite = settings.icon;
            img.color = settings.color;
        }
    }

    public IEnumerator SpinIcon(GameObject obj, int amount)
    {
        float spinsRemaining = amount;
        float displacement = 0;
        Image icon = mapIcons[objects.IndexOf(obj)].GetComponent<Image>();
        float dt = Time.deltaTime;

        while (spinsRemaining > 0)
        {
            float d = -360 * dt * iconSpinoutSpeed;
            displacement += Mathf.Abs(d);
            icon.rectTransform.rotation *= Quaternion.Euler(0, 0, d);

            if (displacement >= 360)
            {
                icon.rectTransform.rotation = Quaternion.Euler(0, 0, 0);
                spinsRemaining--;
                displacement = 0;
            }

            yield return new WaitForSeconds(dt);
        }
    }

    /// <summary>
    /// Allows adding of karts post start
    /// </summary>
    /// <param name="kart"></param>
    public void AddKart(GameObject kart)
    {
        objects.Add(kart);
        GameObject newIcon = Instantiate(iconRef, miniMap.gameObject.transform);
        Image refImage = newIcon.GetComponent<Image>();
        mapIcons.Add(refImage);

        EstablishAppearance(kart, refImage);
    }
}

